死锁:
1. 什么是死锁:
    - 当两个(或更多)线程(或进程)互相持有对方所需要的资源，
    又不主动释放，导致所有人都无法继续前进，导致程序陷入
    无尽的阻塞
    - 死锁的四个必要条件:
        - 锁互斥(一个资源无法被多个线程共享)
        - 请求与保持(请求别的资源，自身也不释放资源)
        - 不剥夺(没有管理者来剥夺线程持有资源)
        - 循环等待(多个线程最后的依赖关系会变成一个环)
        
2. 接触死锁的三种常见方案:
    - 避免死锁
    - 检测与修复
    - 鸵鸟策略

3. 哲学家就餐问题:
    - 产生死锁条件:
        - 左右各有餐具，必须同时持有才可以开吃
        - 所有哲学家拿餐具的顺序必须是一样的(先拿左，再拿右)
    - 解决哲学家就餐问题死锁的四种方案:
        - 服务员调度(避免死锁): 每个哲学家拿餐具的行为由服务员调度
        - 检测死锁并修复: 采用某种策略来检测死锁并修复(和服务员调度方案的检测方案相似)
        - 改变某个哲学家拿取餐具的顺序
        - 餐票机制(比如由5个哲学家，必须持有餐票才能进餐，而餐票一共只有4张)

4. 实际中避免死锁的tips:
    - 使用trylock而不是synchronized
        - trylock可以设置超时时间
    - 多使用JUC中的并发类而不是自己设计锁
    - 尽量降低锁的粒度
    - 尽量缩小同步代码块的大小
    - 给线程起有意义的名字
    - 尽量避免锁的嵌套
    - 银行家算法计算(避免锁的策略)
    - 专锁专用(不要多个功能共用一把锁)