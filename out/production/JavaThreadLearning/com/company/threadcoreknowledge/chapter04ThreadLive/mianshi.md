线程生命周期常见面试问题：
1. 用程序实现**两个线程**交替打印0-100奇偶数
    - synchronized
    - 使用wait/notify
2. 为什么wait()需要在同步代码块内使用：
    - 一般来说，使用wait/notify的场景一般是我们希望
    线程进行交替执行的场景
    - 如果不在同步代码块内使用，则使用wait的线程和使用
    notify的线程是可以随时切换的(没有其他锁/并且都是Runnable)，
    这时候在执行wait前，可能切到另外一个线程把notify全都执行了，
    这样就永远不能唤醒那个使用了wait的线程

3. 为什么线程通信方法`wait()`, `notify()`, `notifyAll()`被定义在Object类里？
    -  这三个方法对应的是锁级别的操作；在Java Object对象中，都有几个位是用来代表锁操作的，
    将这三个方法定义为Object对象的方法，并不矛盾；
    - 另外，这三个方法都必须在synchronized代码块中才可以使用；而synchronized本质是对对象
    加锁使用的代码块；
    - 一个线程可以涉及到同时操作多个锁的情况，这时候如果将这三个方法定义在
    Thread类级别，很不利于扩展
    
4. `wait`方法与`sleep`方法的异同：
    - 相同之处：
        - 都会使线程进入阻塞状态
        - 可以响应中断
    - 不同之处：
        - `wait`必须在同步代码块中，`sleep`不需要
        - `wait`不指定时间时，默认永久等待；`sleep`则必须指定参数
        - `wait`方法在对象中, `sleep`方法在Thread中
        - `wait`方法释放锁，`sleep`方法不释放锁
        
5. `join`方法原理:
    - 本质是对wait方法的调用，调的是子线程的wait方法
    - 每一个Thread方法在run方法结束后，都会对该Thread对象执行
    notify()操作
